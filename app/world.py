# Higly specialised algo, if you want to add feature
# You need to modify it.
# Do the math for direct, and tell to GPT to inverse it.

import numpy as np
from app.models import Angle, Position

bras_horizontal = 70  # mm
bras = 320  # mm
correction_rad = np.radians(95.36)

 # Angles -> Positions (in mm)
def direct(angles: dict[str, Angle]) -> dict:
    ''' Convert angles to position in the world (in mm, from the pivot point 1) '''
    rad_m1 = np.radians(angles["bras_horizontal"].deg)
    rad_m2 = np.radians(-angles["bras1"].deg)
    rad_m3 = np.radians(-angles["bras2"].deg)

    origin = np.array([0.0, 0.0, 0.0])
    pivotM2 = origin + np.array([bras_horizontal, 0, 0])

    angleM2Total = rad_m2 + correction_rad
    pivotM3 = pivotM2 + np.array([
        bras * np.cos(angleM2Total),
        bras * np.sin(angleM2Total),
        0
    ])

    angleM3Total = angleM2Total + rad_m3
    pivotM4 = pivotM3 + np.array([
        bras * np.cos(angleM3Total),
        bras * np.sin(angleM3Total),
        0
    ])

    # Rotation Y autour de M1
    rot_y = np.array([
        [np.cos(rad_m1), 0, np.sin(rad_m1)],
        [0, 1, 0],
        [-np.sin(rad_m1), 0, np.cos(rad_m1)]
    ])

    m1 = rot_y @ origin
    m2 = rot_y @ pivotM2
    m3 = rot_y @ pivotM3
    m4 = rot_y @ pivotM4

    return {
        "bras_horizontal": Position(x=m1[0], y=m1[1], z=m1[2]),
        "bras1": Position(x=m2[0], y=m2[1], z=m2[2]),
        "bras2": Position(x=m3[0], y=m3[1], z=m3[2]),
        "cone": Position(x=m4[0], y=m4[1], z=m4[2])
    }

# Generated by ChatGPT from direct function.
# Position of M4 Pivot (mm) -> Angles
def inverse(position: Position) -> dict[str, Angle]:
    ''' Convert position (in mm, from the pivot point 1) to angles in the world '''

    pos = np.array([position.x, position.y, position.z])
    m1_rad = np.arctan2(pos[2], pos[0])
    horizontal_distance = np.sqrt(pos[0]**2 + pos[2]**2)
    local_target = np.array([horizontal_distance - bras_horizontal, pos[1]])
    d = np.linalg.norm(local_target)

    if d > (2 * bras + 200):
        raise ValueError("Unable to join position.")

    angle_to_target = np.arctan2(local_target[1], local_target[0])
    cos_m3 = (d**2 - 2 * bras**2) / (2 * bras**2)
    cos_m3 = np.clip(cos_m3, -1, 1)
    m3_base = np.arccos(cos_m3)

    def try_solution(elbow_up: bool):
        alpha = np.arccos(np.clip((d**2 + bras**2 - bras**2) / (2 * d * bras), -1, 1))
        m2 = angle_to_target + alpha if elbow_up else angle_to_target - alpha
        m3 = -m3_base if elbow_up else m3_base

        m1_deg = np.degrees(m1_rad)
        m2_deg = -np.degrees(m2 - correction_rad)
        m3_deg = -np.degrees(m3)

        #TODO: We probably need to check constraint here
        return {
            "bras_horizontal": Angle(deg=m1_deg),
            "bras1": Angle(deg=m2_deg),
            "bras2": Angle(deg=m3_deg),
            "cone": Angle(deg=0)
        }

    result = try_solution(elbow_up=False) or try_solution(elbow_up=True)
    if not result:
        raise ValueError("No solution.")

    return result
