import os
import sys
import threading
import time

# The simulator is generated by ChatGPT 4

DEBUG = False

# ===================== UTILITIES =====================
def checksum(data):
    """Calculates the checksum of a data packet."""
    return (~sum(data) & 0xFF)

def build_status_packet(sid, err, params):
    """Builds a status response packet."""
    length = 2 + len(params)  # error + params
    packet = [0xFF, 0xFF, sid, length, err] + params
    chk = checksum(packet[2:])
    packet.append(chk)
    return bytes(packet)

def debugPrint(text: str):
    if DEBUG:
        print(text)

# ===================== SERVO REGISTERS =====================
# Adresses des registres essentielles pour le moteur STS3215
REGISTERS = {
    "MODEL_NUMBER": 0x00,
    "FIRMWARE_VERSION": 0x02,
    "ID": 0x03,
    "TORQUE_ENABLE": 0x24,
    "LED": 0x25,
    "GOAL_POSITION": 0x2A,
    "GOAL_TIME": 0x2C,
    "GOAL_SPEED": 0x2E,
    "ACCELPOSSPEED": 0x29,
    "PRESENT_POSITION": 0x38,
    "PRESENT_SPEED": 0x3A,
    "PRESENT_LOAD": 0x3C,
    "PRESENT_VOLTAGE": 0x3E,
    "PRESENT_TEMPERATURE": 0x3F,
    "MOVING_STATUS": 0x41,
    "CURRENT": 0x43,
    "MODE": 0x21,
}

# ===================== VIRTUAL SERVO =====================
class VirtualServo:
    def __init__(self, sid):
        self.id = sid
        self.position = 2048
        self.target = 2048
        self.speed = 0
        self.moving_speed = 50
        self.torque_enable = 1
        self.voltage = 120  # Represents 12.0V
        self.temperature = 30
        self.load = 0
        self.pending_write = None
        self.is_moving = 0

    def set_goal(self, pos):
        if not self.torque_enable:
            return
        self.target = max(0, min(4095, pos))
        self.is_moving = 1

    def set_speed(self, spd):
        self.moving_speed = max(1, min(1023, spd))

    def update(self):
        if self.position < self.target:
            self.position += min(self.moving_speed, self.target - self.position)
        elif self.position > self.target:
            self.position -= min(self.moving_speed, self.position - self.target)
        
        if self.position == self.target:
            self.speed = 0
            self.is_moving = 0
        else:
            self.speed = self.moving_speed

        self.load = abs(self.target - self.position) // 10
        self.temperature += 0.01 if self.speed > 0 else -0.01
        self.temperature = max(25, min(70, self.temperature))

    def read_register(self, addr, size):
        """Reads the value of one or more registers."""
        # Note: We're removing the print statement here to avoid cluttering the display loop
        val = 0
        
        if addr == REGISTERS["GOAL_POSITION"] and size == 2:
            val = self.target
        elif addr == REGISTERS["GOAL_SPEED"] and size == 2:
            val = self.moving_speed
        elif addr == REGISTERS["PRESENT_POSITION"] and size == 2:
            val = int(self.position)
        elif addr == REGISTERS["PRESENT_SPEED"] and size == 2:
            val = int(self.speed)
        elif addr == REGISTERS["PRESENT_LOAD"] and size == 2:
            val = int(self.load)
        elif addr == REGISTERS["PRESENT_VOLTAGE"] and size == 1:
            val = self.voltage
        elif addr == REGISTERS["PRESENT_TEMPERATURE"] and size == 1:
            val = int(self.temperature)
        elif addr == REGISTERS["MOVING_STATUS"] and size == 1:
            val = self.is_moving
        elif addr == REGISTERS["MODE"] and size == 1:
            val = 0
        else:
            return [0] * size
        
        return [(val >> (8 * i)) & 0xFF for i in range(size)]

    def write_register(self, addr, data):
        """Writes data to one or more registers, handling contiguous data blocks."""
        debugPrint(f"WRITE BLOCK FROM 0x{addr:02x} data {data}")
        
        write_map = {
            REGISTERS["GOAL_POSITION"]: self._write_goal_pos,
            REGISTERS["GOAL_SPEED"]: self._write_speed,
            REGISTERS["TORQUE_ENABLE"]: self._write_torque,
            REGISTERS["ACCELPOSSPEED"]: self._write_acc_pos_speed,
        }
        
        if addr in write_map:
            write_map[addr](data)
        else:
            debugPrint(f"Warning: Write operation not handled for address 0x{addr:02x}.")

    def _write_goal_pos(self, data):
        if len(data) >= 2:
            goal = data[0] | (data[1] << 8)
            self.set_goal(goal)
            
    def _write_speed(self, data):
        if len(data) >= 2:
            spd = data[0] | (data[1] << 8)
            self.set_speed(spd)

    def _write_torque(self, data):
        if len(data) >= 1:
            self.torque_enable = data[0]
    
    def _write_acc_pos_speed(self, data):
        """Handles the writing of acc, pos, and speed from the ACCELPOSSPEED address."""
        if len(data) >= 7:
            accel = data[0]
            goal = data[1] | (data[2] << 8)
            speed = data[5] | (data[6] << 8)
            self.set_goal(goal)
            self.set_speed(speed)
        
    def reg_write(self, addr, data):
        """Registers a pending write."""
        debugPrint(f"REG WRITE 0x{addr:02x}")
        self.pending_write = (addr, data)

    def apply_reg_write(self,):
        """Executes the pending write."""
        debugPrint(f"ACTION on servo {self.id}")
        if self.pending_write:
            addr, data = self.pending_write
            self.write_register(addr, data)
            self.pending_write = None
        else:
            debugPrint(f"ACTION on servo {self.id}: NOTHING TO WRITE")

# ===================== PARSER =====================
ERRORS = {
    0x00: "No Error",
    0x01: "Overheating Error",
    0x02: "Overload Error",
    0x04: "Overvoltage Error",
    0x08: "Overheating/Overload Error",
    0x10: "Instruction Error",
    0x20: "Checksum Error",
    0x40: "Register Error",
}

def parse_command(data, servos):
    if len(data) < 6 or data[0] != 0xFF or data[1] != 0xFF:
        # print("Malformed command frame.")
        return build_status_packet(0, 0x10, [])

    sid = data[2]
    length = data[3]
    cmd = data[4]
    params = data[5:-1]
    chk = data[-1]

    if checksum(data[2:-1]) != chk:
        # print("Incorrect checksum.")
        return build_status_packet(sid, 0x20, [])
    
    # We remove this print to avoid clutter in the display loop
    # print(f"COMMAND 0x{cmd:02x} for SID {sid}")

    if cmd == 0x01:  # PING
        targets = [servos[sid]] if sid in servos else []
        if sid == 254:
            targets = list(servos.values())
        if targets:
            return build_status_packet(sid, 0, [])

    elif cmd == 0x02:  # READ_DATA
        targets = [servos[sid]] if sid in servos else []
        if len(params) < 2:
            return build_status_packet(sid, 0x10, [])
        addr, size = params[0], params[1]
        
        if sid == 254:
            return build_status_packet(sid, 0x10, [])
        if not targets:
            return None

        regs_data = targets[0].read_register(addr, size)
        return build_status_packet(sid, 0, regs_data)
    
    elif cmd == 0x03:  # WRITE_DATA
        targets = [servos[sid]] if sid in servos else []
        if sid == 254:
            targets = list(servos.values())
        if len(params) < 2:
            return build_status_packet(sid, 0x10, [])
        addr, data_w = params[0], params[1:]
        
        for s in targets:
            s.write_register(addr, data_w)
        
        if sid != 254:
            return build_status_packet(sid, 0, [])

    elif cmd == 0x04:  # REG_WRITE
        targets = [servos[sid]] if sid in servos else []
        if sid == 254:
            targets = list(servos.values())
        if len(params) < 2:
            return build_status_packet(sid, 0x10, [])
        addr, data_w = params[0], params[1:]
        
        for s in targets:
            s.reg_write(addr, data_w)
        
        if sid != 254:
            return build_status_packet(sid, 0, [])

    elif cmd == 0x05:  # ACTION
        for s in servos.values():
            s.apply_reg_write()
        return None
    
    elif cmd == 0x83: # SYNC_WRITE
        if len(params) < 3:
            return build_status_packet(254, 0x10, [])
        
        addr, len_data = params[0], params[1]
        sync_data = params[2:]
        
        if len(sync_data) % (len_data + 1) != 0:
            return build_status_packet(254, 0x10, [])
            
        num_servos = len(sync_data) // (len_data + 1)
        
        for i in range(num_servos):
            start = i * (len_data + 1)
            end = start + len_data + 1
            servo_id = sync_data[start]
            data_to_write = sync_data[start+1:end]
            
            if servo_id in servos:
                servos[servo_id].reg_write(addr, data_to_write)
        
        return None

    # print(f"COMMAND 0x{cmd:02x} not recognized")
    return build_status_packet(sid, 0x10, [])

# ===================== PTS SIMULATOR =====================
class ServoPTS:
    def __init__(self):
        if sys.platform.startswith('win'):
            # Windows does not support os.openpty or os.ttyname
            raise NotImplementedError("Pseudo-terminal operations are not supported on Windows.")
        else:
            self.master, self.slave = os.openpty()
            self.slave_name = os.ttyname(self.slave)
            
        self.servos = {i: VirtualServo(i) for i in range(1, 5)}
        self.lock = threading.Lock()
        self.running_display = True
        print(f"[EMU] Virtual serial port created: {self.slave_name}")
        print(f"[EMU] Connect your controller to this port to interact with the servos.")
        
    def read_all_servo_data(self):
        """Reads position, speed, load, and temp for all servos and returns them."""
        data = {}
        for sid in self.servos:
            data[sid] = {}
            with self.lock:
                # Read Position (2 bytes)
                pos_resp = parse_command([0xFF, 0xFF, sid, 0x04, 0x02, REGISTERS["PRESENT_POSITION"], 0x02, checksum([sid, 0x04, 0x02, REGISTERS["PRESENT_POSITION"], 0x02])], self.servos)
                pos = pos_resp[5] | (pos_resp[6] << 8) if pos_resp and len(pos_resp) >= 7 else 0
                data[sid]["position"] = pos

                # Read Speed (2 bytes)
                speed_resp = parse_command([0xFF, 0xFF, sid, 0x04, 0x02, REGISTERS["PRESENT_SPEED"], 0x02, checksum([sid, 0x04, 0x02, REGISTERS["PRESENT_SPEED"], 0x02])], self.servos)
                speed = speed_resp[5] | (speed_resp[6] << 8) if speed_resp and len(speed_resp) >= 7 else 0
                data[sid]["speed"] = speed

                # Read Load (2 bytes)
                load_resp = parse_command([0xFF, 0xFF, sid, 0x04, 0x02, REGISTERS["PRESENT_LOAD"], 0x02, checksum([sid, 0x04, 0x02, REGISTERS["PRESENT_LOAD"], 0x02])], self.servos)
                load = load_resp[5] | (load_resp[6] << 8) if load_resp and len(load_resp) >= 7 else 0
                data[sid]["load"] = load

                # Read Temperature (1 byte)
                temp_resp = parse_command([0xFF, 0xFF, sid, 0x04, 0x02, REGISTERS["PRESENT_TEMPERATURE"], 0x01, checksum([sid, 0x04, 0x02, REGISTERS["PRESENT_TEMPERATURE"], 0x01])], self.servos)
                temp = temp_resp[5] if temp_resp and len(temp_resp) >= 6 else 0
                data[sid]["temp"] = temp
        return data

    def display_loop(self):
        """Continuously displays servo data on the console."""
        while self.running_display:
            os.system('cls' if os.name == 'nt' else 'clear')
            
            print(f"==================== SERVO DATA ({self.slave_name}) ====================")
            servo_data = self.read_all_servo_data()
            
            for sid, values in servo_data.items():
                print(f"--- Servo ID: {sid} ---")
                print(f"  Position:  {values['position']:<4d}  |  Speed:  {values['speed']:<4d}")
                print(f"  Load:      {values['load']:<4d}  |  Temp:   {values['temp']:<4d} Â°C")
                print("-" * 28)
            time.sleep(0.5)
            
    def run(self):
        threading.Thread(target=self.update_loop, daemon=True).start()
        threading.Thread(target=self.display_loop, daemon=True).start()
        
        try:
            while True:
                data = os.read(self.master, 128)
                if not data:
                    continue
                
                with self.lock:
                    resp = parse_command(list(data), self.servos)
                
                if resp:
                    os.write(self.master, resp)
        except Exception as e:
            print(f"Execution error: {e}")
            self.running_display = False
            
    def update_loop(self):
        while True:
            with self.lock:
                for s in self.servos.values():
                    s.update()
            time.sleep(0.02)

# ===================== LAUNCH =====================
if __name__ == "__main__":
    emu = ServoPTS()
    emu.run()